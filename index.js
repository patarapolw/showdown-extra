// @ts-check
const showdown = require('showdown')
const HyperPug = require('hyperpug').default
const scopeCss = require('scope-css')
const shortid = require('shortid')
const h = require('hyperscript')
const { createIndentedFilter, stripIndent } = require('indent-utils')

const ext = {
  /**
   * @type {Object.<string, showdown.ShowdownExtension>}
   */
  showdown: {},
  /**
   * @type {Object.<string, function (string): string>}
   */
  hyperpug: {}
}

class ShowdownExtra {
  /**
   * Options:
   * - [options.id] Unique ID, to be able to contain CSS (default: autogenerated)
   * - [options.flavor] Markdown flavor (default: "github")
   * - [options.frontmatter] Whether to parse YAML frontmatter (default: false)
   *
   * @param {object} options
   * @param {string} [options.id]
   * @param {showdown.Flavor} [options.flavor]
   * @param {boolean | string} [options.frontmatter]
   */
  constructor (options = {}) {
    const {
      id = `showdown-extra__${shortid.generate()}`,
      flavor = 'github',
      frontmatter
    } = options

    this.id = id
    this.frontmatterName = typeof frontmatter === 'string' ? frontmatter : 'Front Matter'

    this.converter = new showdown.Converter({
      parseImgDimensions: true,
      simplifiedAutoLink: true,
      strikethrough: true,
      tables: true,
      disableForced4SpacesIndentedSublists: true,
      backslashEscapesHTMLTags: true,
      emoji: true,
      metadata: !!frontmatter
    })

    if (flavor) {
      this.converter.setFlavor(flavor)
    }

    this.ext = {
      /**
       * @type {Object.<string, showdown.ShowdownExtension>}
       */
      showdown: {
        hyperpug: {
          type: 'lang',
          filter: createIndentedFilter('hyperpug', (s) => {
            return this._hyperpugParse(s)
          })
        },
        inlineHyperpug: {
          type: 'lang',
          regex: /(\\)?#\{([^}]+)\}/g,
          replace: (p0, p1, p2) => {
            return p1 ? p0 : this._hyperpugParse(p2)
          }
        },
        youtube: {
          type: 'lang',
          filter: createIndentedFilter('youtube', (s) => {
            return stripIndent(`
            <iframe width="560" height="315" 
              src="https://www.youtube.com/embed/${s}"
              frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen></iframe>`)
          })
        },
        spoiler: {
          type: 'lang',
          filter: createIndentedFilter('spoiler', (s, { summary }) => {
            return h('details', {
              style: {
                'margin-bottom': '1rem'
              }
            }, [
              h('summary', summary || 'spoiler'),
              h('div', { innerHTML: s })
            ]).outerHTML
          })
        },
        blur: {
          type: 'lang',
          /**
           * @param {string} s
           * @param {showdown.Converter} conv
           */
          filter: createIndentedFilter('blur', (s) => {
            return h('div', {
              style: {
                filter: 'blur(10px)'
              },
              attrs: {
                onclick: 'this.style.filter = this.style.filter ? "" : this.getAttribute("data-filter")',
                'data-filter': 'blur(10px)'
              },
              innerHTML: this.converter.makeHtml(s)
            }).outerHTML
          })
        }
      },
      /**
       * @type {Object.<string, function (string): string>}
       */
      hyperpug: {
        /**
         * @param {string} s
         */
        markdown: (s) => this._showdownParse(s),
        /**
         * @param {string} s
         */
        css: (s) => this._showdownParse(s)
      }
    }

    Object.entries(ext.showdown).map(([k, v]) => this.converter.addExtension(v, k))
    Object.entries(this.ext.showdown).map(([k, v]) => this.converter.addExtension(v, `this.${k}`))

    this.lastHtml = ''
    this.lastMetadata = {
      value: '',
      type: 'yaml'
    }
  }

  /**
   * Convert Markdown to HTML
   * @param {string} s markdown
   * @returns {string} html
   */
  parse (s) {
    try {
      this.lastHtml = this.converter.makeHtml(s)
      const m = this.converter.getMetadata(true)
      this.lastMetadata = {
        value: typeof m === 'string' ? m : JSON.stringify(m),
        type: this.converter.getMetadataFormat()
      }
    } catch (e) {}

    return this.activate(this._finalizeHtml(this.lastHtml, this.lastMetadata))
  }

  /**
   * Commit required changes for the browser, if not done yet.
   * @param {string} output
   */
  activate (output) {
    if (typeof window !== 'undefined') {
      const div = document.getElementById(this.id) || document.createElement('div')
      div.innerHTML = output

      Array.from(div.getElementsByTagName('style')).forEach((el0) => {
        const html = el0.innerHTML.trim()

        if (html) {
          el0.innerHTML = scopeCss(html, `#${this.id}`)
        }
      })

      return div.innerHTML
    }

    return output
  }

  /**
   *
   * @param {string} s
   * @returns {string}
   */
  _hyperpugParse (s) {
    return new HyperPug({
      ...ext.hyperpug,
      ...this.ext.hyperpug
    }).parse(s)
  }

  /**
   *
   * @param {string} s
   * @returns {string}
   */
  _showdownParse (s) {
    return this.converter.makeHtml(s)
  }

  /**
   *
   * @param {string} s
   * @param {object} metadata
   * @param {string} metadata.value
   * @param {string} metadata.type
   * @returns {string}
   */
  _finalizeHtml (s, metadata) {
    return h('div', { id: this.id }, [
      ...(metadata.value ? [
        h('details', { attrs: { open: '' } }, [
          h('summary', this.frontmatterName),
          h('pre', [
            h(`code.language-${metadata.type || 'yaml'}`, metadata.value)
          ])
        ])
      ] : []),
      h('main', { innerHTML: s })
    ]).outerHTML
  }
}

ShowdownExtra.ext = ext

module.exports = ShowdownExtra
